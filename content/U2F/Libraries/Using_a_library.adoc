== Implementing U2F using a library ==
Let us have a look at the U2F sequence diagram:

++++
<div class="diagram">
participant Token
participant Browser
Browser->Server: username and\npassword
Note over Server: verify username\nand password
Note over Server: generate U2F\nchallenge
Server->Browser: challenge (e.g. embedded\nin a HTML page)
Browser->Token: challenge
Note over Token: user touches\nbutton
Token-->Browser: response
Browser-->Server: response
Note over Server: verify response
</div>
++++

=== Server-side ===

A server-side U2F library has 4 basic functions: _Start registration, Finish registration, Start authentication_ and _Finish authentication_.
Below is an example of how these functions can be used in a web server:

==== Registration ====

[source, python]
----
# handles HTTP requests to /start_registration
def start_registration(username, password):
  verify_user_pass(username, password)
  challenge = u2f.start_registration(APP_ID) # generate challenge
  challenge_store.set(username, challenge)
  return challenge
----

[source, python]
----
# handles HTTP requests to /finish_registration
def finish_registration(username, password, deviceResponse):
  challenge = challenge_store.get(username)
  registered_device = u2f.finish_registration(challenge, deviceResponse) # verify response
  device_store.set(username, registered_device)
  challenge_store.delete(username)
  return "Success!"
----

==== Authentication ====

[source, python]
----
# handles HTTP requests to /start_authentication
def start_authentication(username, password):
  verify_user_pass(username, password)
  registered_device = device_store.get(username)
  challenge = u2f.start_authentication(registered_device, APP_ID) # generate challenge
  challenge_store.set(username, challenge)
  return challenge
----

[source, python]
----
# handles HTTP requests to /finish_authentication
def finish_authentication(username, password, deviceResponse):
  challenge = challenge_store.get(username)
  u2f.finish_authentication(challenge, deviceResponse, registered_device) # verify response
  challenge_store.delete(username)
  return "Success!"
----

In the example above `challenge_store` is a link:http://en.wikipedia.org/wiki/Data_access_object[DAO] that stores
challenges temporarily. The other DAO, `device_store`, persists data permanently. For link:../App_ID.html[most cases],
`APP_ID` is the base URL of this web app, for example:

[source, python]
APP_ID = "https://login.example.com"

A U2F client (e.g. Chrome) will compare the AppID with the current URI, which means that you might have to
add an entry to your hosts file during development. For example:

	127.0.0.1 login.example.com


=== Client-side  ===
The main part of the client (web browser) is to
be a middle-man between the server and the U2F device.

Below is an example snippet using JQuery. The `u2f` object is provided by browsers that supports U2F.

[source, javascript]
/* u2f-login.html */
var challenge = // From the server (e.g. this row could be dynamically generated by the server)
u2f.sign([challenge], [], // Forward challenge to device
  function(deviceResponse) {
	$('#u2f-form-data').val(JSON.stringify(deviceResponse));
	$('#u2f-form').submit(); // Send device response back to server
  }
);

When registering a new device `u2f.register` is used instead of `u2f.sign`. The complete U2F JavaScript API can
be found in link:https://fidoalliance.org/specifications/download[the list of U2F specifications].

=== Complete example code
For complete example code (both server and client) in various languages, have a look at link:List_of_libraries.html[respective U2F library]'s accompanied demo server.


pass::[<script src="jquery-1.11.1.min.js"></script><script src="raphael-min.js"></script><script src="underscore-min.js"></script><script src="sequence-diagram-min.js"></script><script>$(".diagram").sequenceDiagram({theme: 'simple'});</script>]

